/*
 * Your application specific code will go here
 */
import * as ko from "knockout";
import Router = require("ojs/ojrouter");
import * as ThemeUtils from "ojs/ojthemeutils";
import * as ModuleElementUtils from "ojs/ojmodule-element-utils";
import * as ModuleAnimations from "ojs/ojmoduleanimations";
import ArrayDataProvider = require("ojs/ojarraydataprovider");
import * as KnockoutTemplateUtils from "ojs/ojknockouttemplateutils";
import "ojs/ojknockout";
import "ojs/ojmodule-element";
import { ModuleElementAnimation } from "ojs/ojmodule-element";
import { RouterState } from "ojs/ojrouterstate";
import { ojNavigationList } from "ojs/ojnavigationlist";
import { ojModule, ModuleViewModel } from "ojs/ojmodule-element";

class NavDataItem {
  id: string;
  name: string;
  iconClass: string;

  constructor( { id, name, iconClass } : {
    id: string;
    name: string;
    iconClass: string
  }) {
    this.id = id;
    this.name = name;
    this.iconClass = iconClass;
  }
}

class HeaderModel implements ModuleViewModel {
  pageTitle: string;
  adjustContentPadding: Function;

  constructor( { pageTitle, adjustContentPadding } : {
    pageTitle: string;
    adjustContentPadding: Function;
  }) {
    this.pageTitle = pageTitle;
    this.adjustContentPadding = adjustContentPadding;
  }

  transitionCompleted(): null {
    // adjust content padding after header bindings have been applied
    this.adjustContentPadding();
    return null;
  }
}

class RootViewModel {
  KnockoutTemplateUtils: typeof KnockoutTemplateUtils;
  manner: ko.Observable<string>;
  message: ko.Observable<string|undefined>;
  router: Router;
  moduleConfig: ko.Observable<ojModule["config"]>;
  moduleAnimation: ModuleElementAnimation;
  navDataProvider: ojNavigationList<string, NavDataItem>["data"];
  platform: string;

  constructor () {
      this.KnockoutTemplateUtils = KnockoutTemplateUtils;

      // handle announcements sent when pages change, for Accessibility.
      this.manner = ko.observable("polite");
      this.message = ko.observable();

      let globalBodyElement: HTMLElement = document.getElementById("globalBody") as HTMLElement;
      globalBodyElement.addEventListener("announce", this.announcementHandler, false);

      // save the theme so we can perform platform specific navigational animations
      this.platform = ThemeUtils.getThemeTargetPlatform() as string;

      // router setup
      this.router = Router.rootInstance;

      this.router.configure({
       "dashboard": {label: "Dashboard", isDefault: true},
       "incidents": {label: "Incidents"},
       "customers": {label: "Customers"},
       "profile": {label: "Profile"},
       "about": {label: "About"}
      });

      Router.defaults.urlAdapter = new Router.urlParamAdapter();

      this.moduleConfig = ko.observable({"view": [], "viewModel": null});

      this.moduleAnimation = ModuleAnimations.switcher(this.switcherCallback);

      // navigation setup
      let navData: NavDataItem[] = [
        new NavDataItem({name: "Dashboard", id: "dashboard",
        iconClass: "oj-navigationlist-item-icon demo-icon-font-24 demo-chart-icon-24"}),
        new NavDataItem({name: "Incidents", id: "incidents",
        iconClass: "oj-navigationlist-item-icon demo-icon-font-24 demo-fire-icon-24"}),
        new NavDataItem({name: "Customers", id: "customers",
        iconClass: "oj-navigationlist-item-icon demo-icon-font-24 demo-people-icon-24"}),
        new NavDataItem({name: "Profile", id: "profile",
        iconClass: "oj-navigationlist-item-icon demo-icon-font-24 demo-person-icon-24"}),
        new NavDataItem({name: "About", id: "about",
        iconClass: "oj-navigationlist-item-icon demo-icon-font-24 demo-info-icon-24"})
      ];

      this.navDataProvider = new ArrayDataProvider(navData, {keyAttributes: "id"});
    }

    // callback function that can return different animations based on application logic.
    switcherCallback = (context: ModuleAnimations.SwitcherCallBackParam): any =>  {
      if (this.platform === "android") {
        return "fade";
      }
      return null;
    }

    announcementHandler = (event: any): void => {
      setTimeout(() => {
        this.message(event.detail.message);
        this.manner(event.detail.manner);
      }, 200);
    }

    loadModule(): void {
      ko.computed( () => {
        let name: string = this.router.moduleConfig.name();
        let viewPath: string = `views/${name}.html`;
        let modelPath: string = `viewModels/${name}`;
        let masterPromise: Promise<any> = Promise.all([
          ModuleElementUtils.createView({"viewPath": viewPath}),
          ModuleElementUtils.createViewModel({"viewModelPath": modelPath})
        ]);
        masterPromise.then((values) => {
            this.moduleConfig({"view": values[0],"viewModel": values[1].default});
          }
        );
      });
    }

    // header Setup
    getHeaderModel(): HeaderModel {
      let currentState: RouterState = this.router.currentState() as RouterState;
      let pageTitle: string = currentState.label as string;
      let adjustContentPadding: Function = this.adjustContentPadding;
      return new HeaderModel( { pageTitle, adjustContentPadding } );
    }

    // method for adjusting the content area top/bottom paddings to avoid overlap with any fixed regions.
    // this method should be called whenever your fixed region height may change.  The application
    // can also adjust content paddings with css classes if the fixed region height is not changing between
    // views.
    adjustContentPadding(): void {
      let topElem: HTMLElement = document.getElementsByClassName("oj-applayout-fixed-top")[0] as HTMLElement;
      let contentElem: HTMLElement = document.getElementsByClassName("oj-applayout-content")[0] as HTMLElement;
      let bottomElem: HTMLElement = document.getElementsByClassName("oj-applayout-fixed-bottom")[0] as HTMLElement;

      if (topElem) {
        contentElem.style.paddingTop = `${topElem.offsetHeight}px`;
      }

      if (bottomElem) {
        contentElem.style.paddingBottom = `${bottomElem.offsetHeight}px`;
      }
      // add oj-complete marker class to signal that the content area can be unhidden.
      // see the override.css file to see when the content area is hidden.
      contentElem.classList.add("oj-complete");
    }
}

export default new RootViewModel();