/*
 * Your application specific code will go here
 */

class ToolBarButtonDataSourceItem {
    id: string;
    label: string;
    iconClasses: string;
    clickCallback: Function;

    constructor ( { id, label, iconClasses, clickCallback } : {
        id: string;
        label: string;
        iconClasses: string;
        clickCallback: Function;
    } ) {
        this.id = id;
        this.label = label;
        this.iconClasses = iconClasses;
        this.clickCallback = clickCallback;
    }
}

class RootViewModel {
    toolbarButtonDataSource: ToolBarButtonDataSourceItem[];

    constructor() {
        // toolbar setup
        this.toolbarButtonDataSource = [
            new ToolBarButtonDataSourceItem({"id": "delete", "label": "Delete", "iconClasses": "demo-icon-font demo-garbage-icon-24",
            "clickCallback": this.deleteCallback}),
            new ToolBarButtonDataSourceItem({"id": "copy","label": "Copy", "iconClasses": "demo-icon-font demo-copy-icon-24",
            "clickCallback": this.copyCallback}),
            new ToolBarButtonDataSourceItem({"id": "edit","label": "Edit", "iconClasses": "demo-icon-font demo-edit-icon-24",
            "clickCallback": this.editCallback}),
            new ToolBarButtonDataSourceItem({"id": "download","label": "Download", "iconClasses": "demo-icon-font demo-download-icon-24",
            "clickCallback": this.downloadCallback}),
            new ToolBarButtonDataSourceItem({"id": "share","label": "Share", "iconClasses": "demo-icon-font demo-share-icon-16",
            "clickCallback": this.shareCallback})
        ];
    }

    // method for adjusting the content area top/bottom paddings to avoid overlap with any fixed regions.
    // this method should be called whenever your fixed region height may change.  The application
    // can also adjust content paddings with css classes if the fixed region height is not changing between
    // views.
    adjustContentPadding(): void {
        let topElem: HTMLElement = document.getElementsByClassName("oj-applayout-fixed-top")[0] as HTMLElement;
        let contentElem: HTMLElement = document.getElementsByClassName("oj-applayout-content")[0] as HTMLElement;
        let bottomElem: HTMLElement = document.getElementsByClassName("oj-applayout-fixed-bottom")[0] as HTMLElement;
        if (topElem) {
            contentElem.style.paddingTop = `${topElem.offsetHeight}px`;
        }
        if (bottomElem) {
            contentElem.style.paddingBottom = `${bottomElem.offsetHeight}px`;
        }
        // add oj-complete marker class to signal that the content area can be unhidden.
        // see the override.css file to see when the content area is hidden.
        contentElem.classList.add("oj-complete");
    }

    deleteCallback = (): void => {
        // delete toolbar button callback
    }

    copyCallback = (): void => {
        // copy toolbar button callback
    }

    editCallback = (): void => {
        // edit toolbar button callback
    }

    downloadCallback = (): void => {
        // download toolbar button callback
    }

    shareCallback = (): void => {
        // share toolbar button callback
    }
}

export default new RootViewModel();